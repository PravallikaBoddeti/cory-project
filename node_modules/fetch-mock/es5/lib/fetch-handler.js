'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('./debug'),
    debug = _require.debug,
    setDebugPhase = _require.setDebugPhase,
    getDebug = _require.getDebug;

var responseBuilder = require('./response-builder');
var requestUtils = require('./request-utils');
var FetchMock = {};

// see https://heycam.github.io/webidl/#aborterror for the standardised interface
// Note that this differs slightly from node-fetch

var AbortError = function (_Error) {
	(0, _inherits3.default)(AbortError, _Error);

	function AbortError() {
		(0, _classCallCheck3.default)(this, AbortError);

		var _this = (0, _possibleConstructorReturn3.default)(this, (AbortError.__proto__ || (0, _getPrototypeOf2.default)(AbortError)).apply(this, arguments));

		_this.name = 'AbortError';
		_this.message = 'The operation was aborted.';

		// Do not include this class in the stacktrace
		if (Error.captureStackTrace) {
			Error.captureStackTrace(_this, _this.constructor);
		}
		return _this;
	}

	return AbortError;
}(Error);

var resolve = function () {
	var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref, url, options, request) {
		var response = _ref.response,
		    _ref$responseIsFetch = _ref.responseIsFetch,
		    responseIsFetch = _ref$responseIsFetch === undefined ? false : _ref$responseIsFetch;
		var debug;
		return _regenerator2.default.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						debug = getDebug('resolve()');

						debug('Recursively resolving function and promise responses');
						// We want to allow things like
						// - function returning a Promise for a response
						// - delaying (using a timeout Promise) a function's execution to generate
						//   a response
						// Because of this we can't safely check for function before Promisey-ness,
						// or vice versa. So to keep it DRY, and flexible, we keep trying until we
						// have something that looks like neither Promise nor function

					case 2:
						if (!true) {
							_context.next = 30;
							break;
						}

						if (!(typeof response === 'function')) {
							_context.next = 17;
							break;
						}

						debug('  Response is a function');
						// in the case of falling back to the network we need to make sure we're using
						// the original Request instance, not our normalised url + options

						if (!responseIsFetch) {
							_context.next = 13;
							break;
						}

						if (!request) {
							_context.next = 9;
							break;
						}

						debug('  -> Calling fetch with Request instance');
						return _context.abrupt('return', response(request));

					case 9:
						debug('  -> Calling fetch with url and options');
						return _context.abrupt('return', response(url, options));

					case 13:
						debug('  -> Calling response function');
						response = response(url, options, request);

					case 15:
						_context.next = 28;
						break;

					case 17:
						if (!(typeof response.then === 'function')) {
							_context.next = 25;
							break;
						}

						debug('  Response is a promise');
						debug('  -> Resolving promise');
						_context.next = 22;
						return response;

					case 22:
						response = _context.sent;
						_context.next = 28;
						break;

					case 25:
						debug('  Response is not a function or a promise');
						debug('  -> Exiting response resolution recursion');
						return _context.abrupt('return', response);

					case 28:
						_context.next = 2;
						break;

					case 30:
					case 'end':
						return _context.stop();
				}
			}
		}, _callee, undefined);
	}));

	return function resolve(_x, _x2, _x3, _x4) {
		return _ref2.apply(this, arguments);
	};
}();

FetchMock.fetchHandler = function (url, options, request) {
	setDebugPhase('handle');
	var debug = getDebug('fetchHandler()');
	debug('fetch called with:', url, options);
	var normalizedRequest = requestUtils.normalizeRequest(url, options, this.config.Request);

	url = normalizedRequest.url;
	options = normalizedRequest.options;
	request = normalizedRequest.request;
	var signal = normalizedRequest.signal;


	debug('Request normalised');
	debug('  url', url);
	debug('  options', options);
	debug('  request', request);
	debug('  signal', signal);

	if (request && this.routes.some(function (_ref3) {
		var usesBody = _ref3.usesBody;
		return usesBody;
	})) {
		debug('Need to wait for Body to be streamed before calling router: switching to async mode');
		return this._asyncFetchHandler(url, options, request, signal);
	}
	return this._fetchHandler(url, options, request, signal);
};

FetchMock._asyncFetchHandler = function () {
	var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(url, options, request, signal) {
		return _regenerator2.default.wrap(function _callee2$(_context2) {
			while (1) {
				switch (_context2.prev = _context2.next) {
					case 0:
						_context2.next = 2;
						return options.body;

					case 2:
						options.body = _context2.sent;
						return _context2.abrupt('return', this._fetchHandler(url, options, request, signal));

					case 4:
					case 'end':
						return _context2.stop();
				}
			}
		}, _callee2, this);
	}));

	return function (_x5, _x6, _x7, _x8) {
		return _ref4.apply(this, arguments);
	};
}();

FetchMock._fetchHandler = function (url, options, request, signal) {
	var _this2 = this;

	var route = this.executeRouter(url, options, request);

	// this is used to power the .flush() method
	var done = void 0;
	this._holdingPromises.push(new this.config.Promise(function (res) {
		return done = res;
	}));

	// wrapped in this promise to make sure we respect custom Promise
	// constructors defined by the user
	return new this.config.Promise(function (res, rej) {
		if (signal) {
			debug('signal exists - enabling fetch abort');
			var abort = function abort() {
				debug('aborting fetch');
				// note that DOMException is not available in node.js; even node-fetch uses a custom error class: https://github.com/bitinn/node-fetch/blob/master/src/abort-error.js
				rej(typeof DOMException !== 'undefined' ? new DOMException('The operation was aborted.', 'AbortError') : new AbortError());
				done();
			};
			if (signal.aborted) {
				debug('signal is already aborted - aborting the fetch');
				abort();
			}
			signal.addEventListener('abort', abort);
		}

		_this2.generateResponse(route, url, options, request).then(res, rej).then(done, done).then(function () {
			setDebugPhase();
		});
	});
};

FetchMock.fetchHandler.isMock = true;

FetchMock.executeRouter = function (url, options, request) {
	var debug = getDebug('executeRouter()');
	debug('Attempting to match request to a route');
	if (this.getOption('fallbackToNetwork') === 'always') {
		debug('  Configured with fallbackToNetwork=always - passing through to fetch');
		return { response: this.getNativeFetch(), responseIsFetch: true };
	}

	var match = this.router(url, options, request);

	if (match) {
		debug('  Matching route found');
		return match;
	}

	if (this.getOption('warnOnFallback')) {
		console.warn('Unmatched ' + (options && options.method || 'GET') + ' to ' + url); // eslint-disable-line
	}

	this.push({ url: url, options: options, request: request, isUnmatched: true });

	if (this.fallbackResponse) {
		debug('  No matching route found - using fallbackResponse');
		return { response: this.fallbackResponse };
	}

	if (!this.getOption('fallbackToNetwork')) {
		throw new Error('fetch-mock: No fallback response defined for ' + (options && options.method || 'GET') + ' to ' + url);
	}

	debug('  Configured to fallbackToNetwork - passing through to fetch');
	return { response: this.getNativeFetch(), responseIsFetch: true };
};

FetchMock.generateResponse = function () {
	var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(route, url, options, request) {
		var debug, response;
		return _regenerator2.default.wrap(function _callee3$(_context3) {
			while (1) {
				switch (_context3.prev = _context3.next) {
					case 0:
						debug = getDebug('generateResponse()');
						_context3.next = 3;
						return resolve(route, url, options, request);

					case 3:
						response = _context3.sent;

						if (!(response.throws && typeof response !== 'function')) {
							_context3.next = 7;
							break;
						}

						debug('response.throws is defined - throwing an error');
						throw response.throws;

					case 7:
						if (!this.config.Response.prototype.isPrototypeOf(response)) {
							_context3.next = 10;
							break;
						}

						debug('response is already a Response instance - returning it');
						return _context3.abrupt('return', response);

					case 10:
						return _context3.abrupt('return', responseBuilder({
							url: url,
							responseConfig: response,
							fetchMock: this,
							route: route
						}));

					case 11:
					case 'end':
						return _context3.stop();
				}
			}
		}, _callee3, this);
	}));

	return function (_x9, _x10, _x11, _x12) {
		return _ref5.apply(this, arguments);
	};
}();

FetchMock.router = function (url, options, request) {
	var route = this.routes.find(function (route, i) {
		debug('Trying to match route ' + i);
		return route.matcher(url, options, request);
	});

	if (route) {
		this.push({
			url: url,
			options: options,
			request: request,
			identifier: route.identifier
		});
		return route;
	}
};

FetchMock.getNativeFetch = function () {
	var func = this.realFetch || this.isSandbox && this.config.fetch;
	if (!func) {
		throw new Error('fetch-mock: Falling back to network only available on global fetch-mock, or by setting config.fetch on sandboxed fetch-mock');
	}
	return func;
};

FetchMock.push = function (_ref6) {
	var url = _ref6.url,
	    options = _ref6.options,
	    request = _ref6.request,
	    isUnmatched = _ref6.isUnmatched,
	    identifier = _ref6.identifier;

	debug('Recording fetch call', {
		url: url,
		options: options,
		request: request,
		isUnmatched: isUnmatched,
		identifier: identifier
	});
	var args = [url, options];
	args.request = request;
	args.identifier = identifier;
	args.isUnmatched = isUnmatched;
	this._calls.push(args);
};

module.exports = FetchMock;